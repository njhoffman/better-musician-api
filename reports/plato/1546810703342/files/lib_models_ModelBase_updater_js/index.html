<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - lib/models/ModelBase/updater.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib/models/ModelBase/updater.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">188</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">32.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.92</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">const { get, pick, omit, isObject, merge, pickBy, keys, has } = require(&#039;lodash&#039;);
// const StatsD = require(&#039;node-statsd&#039;);
const Promise = require(&#039;bluebird&#039;);

// const sdc = new StatsD();

const _logResult = function _logResult(results, newFields) {
  const { type, inserted, replaced, skipped, unchanged, changes = [] } = results;

  const logMessage = [
    &#039;Successfully&#039;,
    `${replaced ? &#039;replaced &#039; : &#039;&#039;}${replaced || &#039;&#039;}`,
    `${inserted ? &#039;inserted &#039; : &#039;&#039;}${inserted || &#039;&#039;}`,
    `${skipped || unchanged ? &#039; (&#039; : &#039;&#039;}`,
    `${skipped || &#039;&#039;}${skipped ? &#039;skipped&#039; : &#039;&#039;}`,
    `${unchanged || &#039;&#039;}${unchanged ? &#039; unchanged&#039; : &#039;&#039;}`,
    `${skipped || unchanged ? &#039;) &#039; : &#039;&#039;}`,
    `${changes.length} total field changes, `,
    `record(s) during ${type} operation for model %${this.modelName}%`
  ].filter(Boolean).join(&#039; &#039;);

  this.logger.debug({
    _trace: { fields: this.fields, data: newFields, changes },
    _dbOp: {
      table:       this.tableName,
      data:        newFields,
      operation:   inserted ? &#039;create&#039; : &#039;update&#039;,
      resultCount: changes.length,
      changes
    }
  }, logMessage);

  return Promise.resolve(results);
};

const _update = function _update(saveFields, existingId) {
  const toSave = {
    ...omit(saveFields, [&#039;updatedAt&#039;, &#039;id&#039;]),
    updatedAt: new Date().getTime()
  };

  this.logger.debug({ _trace: toSave },
    `Attempting to UPDATE &quot;${this.tableName}&quot; record: ${existingId}`);

  return this.db
    .table(this.tableName)
    .get(existingId)
    .update(toSave, { returnChanges: true })
    .run(this.conn);
};

const _create = function _create(fieldsToAdd) {
  // record creation needs all associated fields for the first save
  const toAdd = {
    ...fieldsToAdd,
    createdAt: new Date().getTime(),
    updatedAt: new Date().getTime()
  };

  this.logger.debug(
    { _debug: toAdd },
    `Attempting to CREATE &quot;${this.tableName}&quot; record`
  );
  return this.db
    .table(this.tableName)
    .insert(toAdd, { returnChanges: true })
    .run(this.conn);
};

const _createForeignRelation = function _createForeignRelation(fKey) {
  if (has(this.rawFields, fKey)) {
    const { relation: { Model } } = this.tableKeys[fKey];

    const dataObj = isObject(this.validatedFields[fKey])
      ? this.validatedFields[fKey]
      : { id: this.validatedFields[fKey] };

    const fModel = new Model(dataObj);
    fModel.parentField = fKey;
    return fModel;
  }
  return false;
};

const _processIncomingFields = function _processIncomingFields(newFields) {
  // only save keys defined in class model
  const fieldsToUpdate = pick(this.validatedFields, (
    keys(this.validatedFields)
      .filter(vKey =&gt; !has(this.tableKeys, vKey.relation))
  ));
  // reverse relations are for reference/seeding purposes only not normal saing
  const fKeys = pickBy(this.tableKeys, (field, fieldKey) =&gt; (
    has(field, &#039;relation&#039;) &amp;&amp; has(newFields, fieldKey)
    // &amp;&amp; !field.relation.reverse
  ));

  const foreignModels = keys(fKeys)
    .map(fKey =&gt; _createForeignRelation.call(this, fKey))
    .filter(Boolean);

  const self = this;
  // save foreign key records and assign new foreign id to relation field
  return Promise.mapSeries(foreignModels, fModel =&gt; (
    Promise.all([fModel.constructor.save(fModel.rawFields), fModel.parentField])
  ))
    .then(fKeySaves =&gt; {
      fKeySaves.forEach(([saveResult, fKey]) =&gt; {
        const { records: { id } } = saveResult;
        fieldsToUpdate[fKey] = id;
      });

      self.processedFields = fieldsToUpdate;
      return fieldsToUpdate;
    });
};

const _handleUpdate = function _handleUpdate(newFields, existingId) {
  // return _doValidation.call(this, newFields)
  // .then(() =&gt; _processFields.call(this, newFields))
  return _processIncomingFields.call(this, newFields)
    .then((toUpdate) =&gt; _update.call(this, toUpdate, existingId));
};

const _handleCreate = function _handleCreate(newFields) {
  const self = this;
  return _processIncomingFields
    .call(this, { ...this.validatedFields, newFields })
    .then((toCreate) =&gt; _create.call(self, toCreate));
};

const _handleResponse = function _handleResponse(results) {
  const { generated_keys: [id] = [], changes, errors, ...other } = results;
  // genereated_keys: [id]
  // sdc.increment(&#039;api_db_create&#039;);

  if (errors &amp;&amp; errors &gt; 0) {
    throw new Error(`ERROR updating Record: ${other.first_error}`);
  } else if (changes.length &gt; 1) {
    throw new Error(`Error: Attempt to update multiple records for ${this.tableName}`, changes);
  }

  // assign main fields property now that data has been saved
  // this.existingFields = this.cleanedFields;
  const changed = this.changedFields(changes);
  const records = changed[0] ? changed[0].new : {};
  const response = {
    parentField: this.parentField,
    records,
    changed,
    ...other
  };

  if (id) {
    merge(response, { id, operation: &#039;create&#039; });
  } else {
    merge(response, { operation: &#039;update&#039; });
  }

  this.updateSavedData(response);
  return response;
};

const Save = function Save(newFields) {
  // existing models for update should be instantiated and updated with newFields
  // new models for create need to be instantiated for validation and parsing
  // instantiation from an update or create always guarantees uniqueness and corret update or create path
  this.logger.debug(
    { _debug: { newFields, rawFields: this.rawFields } },
    `Trying to save data to ${this.modelName}`
  );

  if (newFields) {
    this.validate({ ...this.existingFields, ...newFields });
  }

  const existingId = get(newFields, &#039;id&#039;)
    || get(this.validatedFields, &#039;id&#039;)
    || get(this.existingFields, &#039;id&#039;);

  return (existingId
    ? _handleUpdate.call(this, newFields, existingId)
    : _handleCreate.call(this))
    .then(results =&gt; _logResult.call(this, results, newFields))
    .then(results =&gt; _handleResponse.call(this, results));
};

module.exports = Save;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
